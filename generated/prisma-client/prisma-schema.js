module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateLecture {
  count: Int!
}

type AggregateSchedule {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Lecture {
  id: ID!
  date: String!
  time: String!
  postedBy: User!
}

type LectureConnection {
  pageInfo: PageInfo!
  edges: [LectureEdge]!
  aggregate: AggregateLecture!
}

input LectureCreateInput {
  id: ID
  date: String!
  time: String!
  postedBy: UserCreateOneWithoutLectureInput!
}

input LectureCreateManyWithoutPostedByInput {
  create: [LectureCreateWithoutPostedByInput!]
  connect: [LectureWhereUniqueInput!]
}

input LectureCreateWithoutPostedByInput {
  id: ID
  date: String!
  time: String!
}

type LectureEdge {
  node: Lecture!
  cursor: String!
}

enum LectureOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  time_ASC
  time_DESC
}

type LecturePreviousValues {
  id: ID!
  date: String!
  time: String!
}

input LectureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  AND: [LectureScalarWhereInput!]
  OR: [LectureScalarWhereInput!]
  NOT: [LectureScalarWhereInput!]
}

type LectureSubscriptionPayload {
  mutation: MutationType!
  node: Lecture
  updatedFields: [String!]
  previousValues: LecturePreviousValues
}

input LectureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LectureWhereInput
  AND: [LectureSubscriptionWhereInput!]
  OR: [LectureSubscriptionWhereInput!]
  NOT: [LectureSubscriptionWhereInput!]
}

input LectureUpdateInput {
  date: String
  time: String
  postedBy: UserUpdateOneRequiredWithoutLectureInput
}

input LectureUpdateManyDataInput {
  date: String
  time: String
}

input LectureUpdateManyMutationInput {
  date: String
  time: String
}

input LectureUpdateManyWithoutPostedByInput {
  create: [LectureCreateWithoutPostedByInput!]
  delete: [LectureWhereUniqueInput!]
  connect: [LectureWhereUniqueInput!]
  set: [LectureWhereUniqueInput!]
  disconnect: [LectureWhereUniqueInput!]
  update: [LectureUpdateWithWhereUniqueWithoutPostedByInput!]
  upsert: [LectureUpsertWithWhereUniqueWithoutPostedByInput!]
  deleteMany: [LectureScalarWhereInput!]
  updateMany: [LectureUpdateManyWithWhereNestedInput!]
}

input LectureUpdateManyWithWhereNestedInput {
  where: LectureScalarWhereInput!
  data: LectureUpdateManyDataInput!
}

input LectureUpdateWithoutPostedByDataInput {
  date: String
  time: String
}

input LectureUpdateWithWhereUniqueWithoutPostedByInput {
  where: LectureWhereUniqueInput!
  data: LectureUpdateWithoutPostedByDataInput!
}

input LectureUpsertWithWhereUniqueWithoutPostedByInput {
  where: LectureWhereUniqueInput!
  update: LectureUpdateWithoutPostedByDataInput!
  create: LectureCreateWithoutPostedByInput!
}

input LectureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  postedBy: UserWhereInput
  AND: [LectureWhereInput!]
  OR: [LectureWhereInput!]
  NOT: [LectureWhereInput!]
}

input LectureWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createLecture(data: LectureCreateInput!): Lecture!
  updateLecture(data: LectureUpdateInput!, where: LectureWhereUniqueInput!): Lecture
  updateManyLectures(data: LectureUpdateManyMutationInput!, where: LectureWhereInput): BatchPayload!
  upsertLecture(where: LectureWhereUniqueInput!, create: LectureCreateInput!, update: LectureUpdateInput!): Lecture!
  deleteLecture(where: LectureWhereUniqueInput!): Lecture
  deleteManyLectures(where: LectureWhereInput): BatchPayload!
  createSchedule(data: ScheduleCreateInput!): Schedule!
  updateSchedule(data: ScheduleUpdateInput!, where: ScheduleWhereUniqueInput!): Schedule
  updateManySchedules(data: ScheduleUpdateManyMutationInput!, where: ScheduleWhereInput): BatchPayload!
  upsertSchedule(where: ScheduleWhereUniqueInput!, create: ScheduleCreateInput!, update: ScheduleUpdateInput!): Schedule!
  deleteSchedule(where: ScheduleWhereUniqueInput!): Schedule
  deleteManySchedules(where: ScheduleWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  lecture(where: LectureWhereUniqueInput!): Lecture
  lectures(where: LectureWhereInput, orderBy: LectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lecture]!
  lecturesConnection(where: LectureWhereInput, orderBy: LectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LectureConnection!
  schedule(where: ScheduleWhereUniqueInput!): Schedule
  schedules(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Schedule]!
  schedulesConnection(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScheduleConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Schedule {
  id: ID!
  date: String!
  todo: String!
  postedBy: User!
}

type ScheduleConnection {
  pageInfo: PageInfo!
  edges: [ScheduleEdge]!
  aggregate: AggregateSchedule!
}

input ScheduleCreateInput {
  id: ID
  date: String!
  todo: String!
  postedBy: UserCreateOneWithoutScheduleInput!
}

input ScheduleCreateManyWithoutPostedByInput {
  create: [ScheduleCreateWithoutPostedByInput!]
  connect: [ScheduleWhereUniqueInput!]
}

input ScheduleCreateWithoutPostedByInput {
  id: ID
  date: String!
  todo: String!
}

type ScheduleEdge {
  node: Schedule!
  cursor: String!
}

enum ScheduleOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  todo_ASC
  todo_DESC
}

type SchedulePreviousValues {
  id: ID!
  date: String!
  todo: String!
}

input ScheduleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  todo: String
  todo_not: String
  todo_in: [String!]
  todo_not_in: [String!]
  todo_lt: String
  todo_lte: String
  todo_gt: String
  todo_gte: String
  todo_contains: String
  todo_not_contains: String
  todo_starts_with: String
  todo_not_starts_with: String
  todo_ends_with: String
  todo_not_ends_with: String
  AND: [ScheduleScalarWhereInput!]
  OR: [ScheduleScalarWhereInput!]
  NOT: [ScheduleScalarWhereInput!]
}

type ScheduleSubscriptionPayload {
  mutation: MutationType!
  node: Schedule
  updatedFields: [String!]
  previousValues: SchedulePreviousValues
}

input ScheduleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScheduleWhereInput
  AND: [ScheduleSubscriptionWhereInput!]
  OR: [ScheduleSubscriptionWhereInput!]
  NOT: [ScheduleSubscriptionWhereInput!]
}

input ScheduleUpdateInput {
  date: String
  todo: String
  postedBy: UserUpdateOneRequiredWithoutScheduleInput
}

input ScheduleUpdateManyDataInput {
  date: String
  todo: String
}

input ScheduleUpdateManyMutationInput {
  date: String
  todo: String
}

input ScheduleUpdateManyWithoutPostedByInput {
  create: [ScheduleCreateWithoutPostedByInput!]
  delete: [ScheduleWhereUniqueInput!]
  connect: [ScheduleWhereUniqueInput!]
  set: [ScheduleWhereUniqueInput!]
  disconnect: [ScheduleWhereUniqueInput!]
  update: [ScheduleUpdateWithWhereUniqueWithoutPostedByInput!]
  upsert: [ScheduleUpsertWithWhereUniqueWithoutPostedByInput!]
  deleteMany: [ScheduleScalarWhereInput!]
  updateMany: [ScheduleUpdateManyWithWhereNestedInput!]
}

input ScheduleUpdateManyWithWhereNestedInput {
  where: ScheduleScalarWhereInput!
  data: ScheduleUpdateManyDataInput!
}

input ScheduleUpdateWithoutPostedByDataInput {
  date: String
  todo: String
}

input ScheduleUpdateWithWhereUniqueWithoutPostedByInput {
  where: ScheduleWhereUniqueInput!
  data: ScheduleUpdateWithoutPostedByDataInput!
}

input ScheduleUpsertWithWhereUniqueWithoutPostedByInput {
  where: ScheduleWhereUniqueInput!
  update: ScheduleUpdateWithoutPostedByDataInput!
  create: ScheduleCreateWithoutPostedByInput!
}

input ScheduleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  todo: String
  todo_not: String
  todo_in: [String!]
  todo_not_in: [String!]
  todo_lt: String
  todo_lte: String
  todo_gt: String
  todo_gte: String
  todo_contains: String
  todo_not_contains: String
  todo_starts_with: String
  todo_not_starts_with: String
  todo_ends_with: String
  todo_not_ends_with: String
  postedBy: UserWhereInput
  AND: [ScheduleWhereInput!]
  OR: [ScheduleWhereInput!]
  NOT: [ScheduleWhereInput!]
}

input ScheduleWhereUniqueInput {
  id: ID
}

type Subscription {
  lecture(where: LectureSubscriptionWhereInput): LectureSubscriptionPayload
  schedule(where: ScheduleSubscriptionWhereInput): ScheduleSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  trainer: String!
  schedule(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Schedule!]
  lecture(where: LectureWhereInput, orderBy: LectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lecture!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  trainer: String!
  schedule: ScheduleCreateManyWithoutPostedByInput
  lecture: LectureCreateManyWithoutPostedByInput
}

input UserCreateOneWithoutLectureInput {
  create: UserCreateWithoutLectureInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutScheduleInput {
  create: UserCreateWithoutScheduleInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLectureInput {
  id: ID
  name: String!
  email: String!
  password: String!
  trainer: String!
  schedule: ScheduleCreateManyWithoutPostedByInput
}

input UserCreateWithoutScheduleInput {
  id: ID
  name: String!
  email: String!
  password: String!
  trainer: String!
  lecture: LectureCreateManyWithoutPostedByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  trainer_ASC
  trainer_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  trainer: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  trainer: String
  schedule: ScheduleUpdateManyWithoutPostedByInput
  lecture: LectureUpdateManyWithoutPostedByInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  trainer: String
}

input UserUpdateOneRequiredWithoutLectureInput {
  create: UserCreateWithoutLectureInput
  update: UserUpdateWithoutLectureDataInput
  upsert: UserUpsertWithoutLectureInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutScheduleInput {
  create: UserCreateWithoutScheduleInput
  update: UserUpdateWithoutScheduleDataInput
  upsert: UserUpsertWithoutScheduleInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutLectureDataInput {
  name: String
  email: String
  password: String
  trainer: String
  schedule: ScheduleUpdateManyWithoutPostedByInput
}

input UserUpdateWithoutScheduleDataInput {
  name: String
  email: String
  password: String
  trainer: String
  lecture: LectureUpdateManyWithoutPostedByInput
}

input UserUpsertWithoutLectureInput {
  update: UserUpdateWithoutLectureDataInput!
  create: UserCreateWithoutLectureInput!
}

input UserUpsertWithoutScheduleInput {
  update: UserUpdateWithoutScheduleDataInput!
  create: UserCreateWithoutScheduleInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  trainer: String
  trainer_not: String
  trainer_in: [String!]
  trainer_not_in: [String!]
  trainer_lt: String
  trainer_lte: String
  trainer_gt: String
  trainer_gte: String
  trainer_contains: String
  trainer_not_contains: String
  trainer_starts_with: String
  trainer_not_starts_with: String
  trainer_ends_with: String
  trainer_not_ends_with: String
  schedule_every: ScheduleWhereInput
  schedule_some: ScheduleWhereInput
  schedule_none: ScheduleWhereInput
  lecture_every: LectureWhereInput
  lecture_some: LectureWhereInput
  lecture_none: LectureWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  name: String
  email: String
}
`
      }
    